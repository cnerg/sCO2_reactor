"""This module contains functions to sweep parameter-space, creating MCNP
depletion inputs to calculate keff at EOL.
* AR
* core_z
* cool_r
* PD
* power
* enrich
"""
from pyDOE import lhs
import itertools
import os
import glob
import numpy as np
import tarfile

from mcnp_inputs import HomogeneousInput

# set seed for reproducibility
np.random.seed(1324291)

dimensions = ['AR', 'core_r', 'cool_r', 'PD', 'power', 'enrich']
const_dims = ['cool_r', 'AR', 'PD', 'enrich', 'core_r']

const_vals = {'AR' : 1, 'cool_r' : 0.5, 'core_r' : 20, 'enrich' : 0.9, 'PD' : 1.537}
#parameters = {'core_r'  : (20, 50, 5),         
#              'AR'      : (0.7, 1.3, 0.3),
#              'PD'      : (1.4, 1.6, 0.1),        
#              'enrich'  : (0.3, 0.9, 0.1)
#             }
parameters = {'power' : (80, 400, 20)}

dim = len(parameters.keys())
samples = 40

def gen_hypercube(samples, N):
    """Generate N-dimensional latin hypercube to sample dimensional reactor
    space.

    Arguments:
    ----------
        samples (int): number of test cases to try
        N (int): number of dimensions to test
    
    Returns:
    --------
        cube (ndarray): normalized, N-D latin hypercube
    """

    np.random.seed(4654562)
    hypercube = lhs(N, samples=samples)

    return hypercube

def grid_sampling():
    """Generate evenly-sampled grid space.
    """
    rangeset = []
    for dim in dimensions:
        bounds = parameters[dim]
        rangeset.append(np.arange(bounds[0], bounds[1], bounds[2]))
    grid = list(itertools.product(*rangeset))
    
    array = np.zeros(len(grid), dtype={'names' : dimensions, 
                                       'formats' : ['f8']*len(dimensions)})
    for idx, params in enumerate(grid):
        array[idx] = params

    return array

def fill_data_array(samples, parameters, cube):
    """Fill an ndarray with the sampling set generated by lhs.
    """
    # initialize array
    test_cases = np.zeros(samples, dtype={'names' : dimensions,
                                    'formats' : ['f8']*len(dimensions) })
    # for all samples
    for sample_idx, sample in enumerate(cube):
        # get values for every dimension
        for dim_idx, dim in enumerate(sorted(parameters.keys())):
            l_limit = parameters[dim][0]
            u_limit = parameters[dim][1]
            # uniform distribution
            a = u_limit - l_limit
            b = l_limit
            # save to ndarray
            test_cases[sample_idx][dim] = b + cube[sample_idx][dim_idx] * a
        for dim in const_dims:
            test_cases[sample_idx][dim] = const_vals[dim]
    
    
    return test_cases

def write_inputs(sampling_data):
    """Write MCNP depletion inputs for sampled data.
    """
    datanames = sampling_data.dtype.names
    tarputs = tarfile.open('smpl_mcnp_depl_inps.tar', 'w')
    for num, sample in enumerate(sampling_data):
        input = HomogeneousInput(sample['core_r'],
                                 sample['core_r']*sample['AR'],
                                 sample['power'])
        homog_comp = input.homog_core(sample['enrich'],
                                      sample['cool_r'],
                                      sample['PD'])
        input.write_mat_string(homog_comp)
        
        # identifying header string for post-processing
        header_str = ''
        for param in dimensions:
            header_str += str(round(sample[param], 5)) + ','
        # write the input and tar it
        filename = input.write_input(num, header_str)
        tarputs.add(filename)

    # write HTC input list
    htc_inputs = open('input_list.txt', 'w')
    htc_inputs.write('\n'.join(glob.glob("*.i")))
    htc_inputs.close()
        
    tarputs.add('input_list.txt')
    tarputs.close()

if __name__=='__main__':
    cube = gen_hypercube(samples, dim)
#    data = grid_sampling()
#    print(len(data))
    data = fill_data_array(samples, parameters, cube)
    write_inputs(data)
    # cleanup
    os.system('rm *.i input_list.txt')
